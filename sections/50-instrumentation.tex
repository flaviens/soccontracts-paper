
% \fls{TODO Continue here}
In this section, we express these contracts as a synthesizable \pici (\PICI).
Because it is an information flow property, the \PICI cannot be directly applied to the CPU under verification.
Indeed, in the original CPU before IFT instrumentation or miter construct, the notion of taint~\cite{solt2022cellift,ceesay2024mucfi} or two-trace property~\cite{wang2023specification,dinesh2024conjunct,dinesh2025h,tan2025contractshadowlogic} does not yet exist.
Instead, the \PICI is applied to the construct that supports information flows, which is either a circuit with DIFT instrumentation, or a miter (see Section~\ref{subsec:ift}).

\para{Sticky-one operator}
Fig.~\ref{fig:stickyone} introduces the sticky-one operator, which is a building block of the \PICI.
It models the diamond $\lozenge$ operator in the instrumentations by making its output stick to 1 as soon as its input is 1.
Its output returns to zero only when the system is reset.

\para{\PICI for DIFT}
We first construct the \PICI for CPUs instrumented for DIFT~\cite{tiwari2009complete,solt2022cellift}.
We materialize contract information flows (i.e., arrows ``$\rightarrow$'' in a given contract) from a CPU output signal to a CPU input signal as a wire between the two corresponding taint signals, where a sticky-one operator accommodates for information flows that might return later (i.e., the $\lozenge$ operator).
When multiple CPU outputs have a contract information flow to a single CPU input signal (i.e., there are several arrows ``$\rightarrow$'' in the contract whose right-hand set contains the same input signal), the corresponding taint signals are \texttt{OR}'ed together, meaning that the input signal can be influenced by any of these output signals.
The \PICI for Contract C4 is shown in Fig.~\ref{fig:pic_instrum_taints} when relying on DIFT instrumentation.

\para{\PICI for miter constructs}
The \PICI for a miter construct must ensure that the CPU input signals that are influenced by the CPU output signals are distinct between the two copies of the CPU.
As shown in Fig.~\ref{fig:pic_instrum_miter}, this is achieved using \texttt{XOR} operations between the CPU outputs of the two copies.
Ultimately, another \texttt{XOR} operation with the result of this difference is performed with the input signal, deciding whether for a given input signal, the two copies of the CPU receive the same input, or one copy receives a flipped input.
Note that there is no conceptual difference between the \PICI for DIFT or for a miter, yet the former allows for a more compact \PICI.

% \para{Take-away}
% In Section~\ref{sec:eval}, we will show that when instrumented with the \PICI, the techniques that were originally unable to detect basic timing side-channels due to the verification scope not including caches are now able to detect them.
% Importantly, this requires no change to the verification technique implementation at all, as the \PICI becomes part of the design under verification's taint tracking logic or miter construct from the verification tool's perspective.
% In terms of performance, we will also show that adding the \PICI incurs a negligible overhead.
% However, while the \PICI addresses a necessary condition for maintaining soundness when the CPU under verification is integrated in a system, existing automated constant-time verification tools have other critical shortcomings that affect unsoundness besides platform integration, as we show next in Section~\ref{sec:techniques}.