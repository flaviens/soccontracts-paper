
We show that such contracts can be expressed as a synthesizable \pici (\PICI).
Because it is an information flow property, the \PICI cannot be directly applied to the CPU under verification (in the original CPU before IFT instrumentation or miter construct, the notion of taint~\cite{solt2022cellift,ceesay2024mucfi} or two-trace property~\cite{wang2023specification,dinesh2024conjunct,dinesh2024conjunct,tan2025contractshadowlogic} does not yet exist).
Instead, the \PICI is applied to the construct that supports information flows, which is either a circuit with dynamic information flow tracking instrumentation, or a miter (see Section~\ref{subsec:ift}).
Before we construct the \PICI, we introduce the sticky-one operator in Figure~\ref{fig:stickyone}, whose functionality is to stay at one as soon as it is set to one, and only comes back to zero when the system is reset.
This operator will model the diamond $\lozenge$ operator in the instrumentations.

We first construct the \PICI for CPUs instrumented for dynamic information flow tracking~\cite{tiwari2009complete,solt2022cellift}.
A contract information flow from a CPU output to a CPU input can be immediately expressed as a wire between the two signals' corresponding taint signals, separated by a sticky-one operator to accommodate for information flows that might return later (i.e., to accommodate for the $\lozenge$ operator).
When several CPU outputs have a contract information flow to a single CPU input, the corresponding taint signals can be combined using a logical OR operation, meaning that the input can be influenced by any of these outputs.
The \PICI for the contract in Equation~\ref{dict:contract_cache_interrupt_addressdependent} is shown in Figure~\ref{fig:pic_instrum_taints} when relying on dynamic information flow tracking instrumentation.
\fls{TODO Check consistency between DIFT and TT}

To construct the \PICI for Equation~\ref{dict:contract_cache_interrupt_addressdependent} for a CPU that relies on a miter construct, the \PICI must ensure that the CPU inputs that are influenced by the CPU outputs are distinct between the two copies of the CPU.
This is achieved using \texttt{XOR} operations between the CPU outputs of the two copies.
Ultimately, another \texttt{XOR} operation with the result of this difference is performed with the input, deciding whether for a given input, the two copies of the CPU will receive the same input, or one copy will receive a flipped input.
Note that there is no conceptual difference between the \PICI for a miter construct and the \PICI for a dynamic information flow tracking instrumentation, yet the latter benefits from the abstraction built into the dynamic information flow tracking instrumentation, which allows for a more compact and arguably more intuitive \PICI.

\para{Take-away}
In Section~\ref{sec:eval}, we will show that when instrumented with the \PICI, the techniques that were originally unable to detect basic timing side-channels due to the verification scope not including caches are now able to detect them.
Importantly, this requires no change to the verification technique implementation at all, as the \PICI becomes part of the design under verification's taint tracking logic or miter construct from the verification tool's perspective.
In terms of performance, we will also show that adding the \PICI incurs a negligible overhead.
However, while the \PICI addresses a necessary condition for maintaining soundness when the CPU under verification is integrated in a system, existing automated constant-time verification tools have other critical shortcomings that affect unsoundness besides platform integration, as we show next in Section~\ref{sec:techniques}.