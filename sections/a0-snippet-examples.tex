% Listing~\ref{lst:repeat} illustrates a part of Yosys's codebase that is never covered by the traditional procedural EDA software fuzzers~\cite{vloghammer,verismith,mirtl}.
% 
% \begin{lstlisting}[language=c++,label={lst:yosys-uncovered},caption={Example instance of code in Yosys that is not covered by the traditional procedural EDA software fuzzers},breaklines=true]
%     // Extracted from Yosys/backends/verilog/verilog_backend.cc for 100 files generated by transfuzz
%     1723           0 :         if (cell->type.in(ID($assert), ID($assume), ID($cover)))
%     1724             :         {
%     1725           0 :                 f << stringf("%s" "always%s if (", indent.c_str(), systemverilog ? "_comb" : " @*");
%     1726           0 :                 dump_sigspec(f, cell->getPort(ID::EN));
%     1727           0 :                 f << stringf(") %s(", cell->type.c_str()+1);
%     1728           0 :                 dump_sigspec(f, cell->getPort(ID::A));
%     1729           0 :                 f << stringf(");\n");
%     1730           0 :                 return true;
%     1731             :         }
% \end{lstlisting}

% Listing~\ref{lst:refused} presents an example of SystemVerilog-compliant code but refused by Verilator's linter.

% \begin{lstlisting}[caption={Example of a file rejected by Verilator's linter.},label={lst:refused},language=verilog,breaklines=true]
% module module_loops_complex_cond(
%     input logic [7:0] in_a,
%     input logic [7:0] in_b,
%     input logic [7:0] in_c,
%     output logic [15:0] out_sum
% );
%     logic [15:0] result_sum;
%     always_comb begin
%         result_sum = 16'b0;
%         int i = 0; // error: declaration must come before all statements in the block
%         while ((i < in_a) && ((in_b > 10) || (in_c == 5))) begin
%              result_sum += i;
%              i++;
%              if (i > 20) break; 
%         end
%     end
%     assign out_sum = result_sum;
% endmodule
% \end{lstlisting}


Listing~\ref{lst:repeat} illustrates a snippet generated to target Verilator's handling of repeat constructs.

\begin{lstlisting}[caption={Example of a snippet generated to target Verilator's handling of repeat constructs.},label={lst:repeat},language=verilog,breaklines=true]
/* signature of verilator's repeat handling 
 * function in src/V3LinkJump.cpp 
 *     void visit(AstRepeat* nodep) override {
 */
module module_repeat (
    input logic [3:0] in_times,
    output logic [3:0] out_counter
);
    always_comb begin: repeat_block
        logic [3:0] count_val;
        count_val = 0;
        repeat (in_times) begin
            count_val = count_val + 1;
        end
        out_counter = count_val;
    end
endmodule
\end{lstlisting}

Listing~\ref{lst:ansi-cmp} illustrates ANSI and non-ANSI syntaxes for the same addition semantics.
As the verilog code can be written in two different
styles ANSI and non-ANSI (eg Listing~\ref{lst:ansi-cmp}), \ourname must support both while mutating and rewriting the code in the desired style.
\ourname's parser supports both styles, and must preserve both syntaxes as they have been supplied.
\ourname parses constructs such as functions, tasks, classes, structs, and typedefs.

\begin{lstlisting}[language=verilog,caption={ANSI and non-ANSI styles},label={lst:ansi-cmp},breaklines=true]
module ANSI(
    input logic [7:0] in1,
    input logic [7:0] in2,
    output logic [7:0] out
);
    assign out = in1 + in2;
endmodule

module non_ANSI(in1, in2, out);
    input in1;
    logic [7:0] in1;
    input in2;
    logic [7:0] in2;
    output logic [7:0] out; // Another way to declare a port
    assign out = in1 + in2;
endmodule
\end{lstlisting}


% The same reasoning applies to the other objectives.
If Listing~\ref{lst:repeat} illustrates a snippet to target a syntax feature of the EDA software under study,
the process also managed to generate code to trigger particular optimisation passes.
A such example is provided in Listing~\ref{lst:unroll}.

\begin{lstlisting}[caption={Example of a snippet generated to target Verilator's optimisation of for loops.},label={lst:unroll},language=verilog,breaklines=true]
/* Snippet generated by openai's o3 model to target unrolling of for loops wrapped
 * in generate blocks as described in the src/V3Unroll.cpp file in Verilator's source code 
 * class UnrollVisitor final : public VNVisitor {
 *  // skipped lines
 *  // VISITORS
 *  bool cantUnroll(AstNode* nodep, const char* reason) const {
 *      if (m_generate)
 *          nodep->v3warn(E_UNSUPPORTED, "Unsupported: Can't unroll generate for; " << reason);
 *      UINFO(4, "   Can't Unroll: " << reason << " :" << nodep);
 *      // if (debug() >= 9) nodep->dumpTree("-  cant: ");
 *      V3Stats::addStatSum("Unrolling gave up, "s + reason, 1);
 *      return false;
 *  }
 */
module gen_loop_mod(
    input  logic        dummy,
    output logic [31:0] out_vec
);
    genvar g;
    generate
        for (g = 0; g < 4; g = g + 1) begin : gen_blk
            localparam [7:0] GENVAL = g;
            assign out_vec[g*8 +: 8] = GENVAL;
        end
    endgenerate
endmodule
\end{lstlisting}
