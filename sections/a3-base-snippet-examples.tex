Listing~\ref{lst:postdec} illustrates a snippet generated to target Verilator's handling of post-decrement operators, in which bugs were found in Yosys and Yosys-slang the slang frontend for Yosys.
\begin{lstlisting}[language=verilog,caption={Example of a snippet generated to target Verilator's handling of post-decrement operators.},label={lst:postdec},breaklines=true]
module expr_postsub_comb (
    input logic [7:0] in_val_m2,
    input logic [7:0] sub_val_m2,
    output logic [7:0] out_diff_m2,
    output logic [7:0] var_out_m2
);
    logic [7:0] var_m2;
    always_comb begin
        var_m2 = in_val_m2;
        out_diff_m2 = (var_m2--) - sub_val_m2;
        var_out_m2 = var_m2;
    end
endmodule
\end{lstlisting}

Listing~\ref{lst:wor} illustrates a snippet generated to target Slang's support of \texttt{wor} types, which triggered a bug in Yosys-slang.
\begin{lstlisting}[language=verilog,caption={Example of a snippet generated to target Slang's support of wor types},label={lst:wor},breaklines=true]
module WiredNet (
    input wire data1,
    input wire data2,
    output wire out_wired
);
    wor w_or;
    assign w_or = data1;
    assign w_or = data2;
    assign out_wired = w_or;
endmodule
\end{lstlisting}

Listing~\ref{lst:assert} illustrates a LLM-generated snippet targeting Yosys's handling of \texttt{assert} and \texttt{assume} constructs, which are not covered by the state-of-the-art fuzzers.
These snippets were generated to target these particular constructs in the Verilator codebase but nevertheless trigger the relevant code in yosys.

\begin{lstlisting}[language=verilog,caption={Example of a snippet that targets Yosys's handling of assert and assume constructs.},label={lst:assert},breaklines=true]
module cover_property_mod (
    input logic ack,
    input logic busy,
    input logic clk,
    input logic error,
    input logic req,
    input logic reset_n,
    output logic cover_out
);
    property p_cover_req_without_ack;
        @(posedge clk) disable iff (!reset_n)
        req && !ack;
    endproperty
    cover property (p_cover_req_without_ack);
    property p_cover_back_to_back_req;
        @(posedge clk) disable iff (!reset_n)
        req ##1 req;
    endproperty
    cover property (p_cover_back_to_back_req);
    property p_cover_error_during_req;
        @(posedge clk) disable iff (!reset_n)
        req && error;
    endproperty
    cover property (p_cover_error_during_req);
    always @(posedge clk) begin
        if (reset_n) begin
            cover (busy && req) $display("Covered: System busy during request");
            cover (ack && !req) $display("Covered: Unexpected acknowledge");
        end
    end
    assign cover_out = req || ack || busy;
endmodule

module assume_property_mod (
    input logic clk,
    input logic [1:0] prio_level,
    input logic req,
    input logic reset_n,
    input logic valid_data,
    output logic assume_out
);
    property p_assume_no_req_during_reset;
        @(posedge clk) !reset_n |-> !req;
    endproperty
    assume property (p_assume_no_req_during_reset);
    property p_assume_valid_data_with_req;
        @(posedge clk) disable iff (!reset_n)
        req |-> valid_data;
    endproperty
    assume property (p_assume_valid_data_with_req);
    property p_assume_rare_high_priority;
        @(posedge clk) disable iff (!reset_n)
        req && (prio_level == 2'b11) |-> ##[5:10] !(req && (prio_level == 2'b11));
    endproperty
    assume property (p_assume_rare_high_priority);
    always @(posedge clk) begin
        if (reset_n) begin
            assume property (@(posedge clk) req ##1 req ##1 req |-> ##1 !req);
        end
    end
    assign assume_out = req && valid_data;
endmodule


\end{lstlisting}
