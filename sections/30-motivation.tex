In this section, we analyze code coverage achieved by the state-of-the-art EDA software fuzzers.

\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{plots/coverage_comparison/combined_coverage_comparison.pdf}
    \caption{Line(circle), branch (square), function (triangle) coverage on Verilator, Yosys and Slang for the Verismith (orange), TransFuzz (blue), and VlogHammer (green) fuzzers.
    }
    \label{fig:prev-coverage}
\end{figure}

\para{Methodology}
Line, function, and branch coverage are widely accepted metrics for evaluating the comprehensiveness of a fuzzing campaign~\cite{cadar2008klee,fraser2011evosuite,pacheco2007feedback,godefroid2005dart}.
We evaluate the state-of-the-art EDA software fuzzers VlogHammer~\cite{vloghammer}, Verismith~\cite{verismith} and TransFuzz~\cite{mirtl} against these metrics.

We selected three popular open-source EDA applications for this purpose.
First, the Verilator~\cite{Snyder2024Verilator} RTL simulator, which is regarded as a particularly fast, optimization-heavy simulator.
Second, the Yosys~\cite{wolf2013yosys} synthesizer, which is the de facto standard open-source synthesizer.
Finally, the Slang~\cite{popoloski2019slang} parser, which offers the broadest SystemVerilog language support among open-source tools~\cite{chipsalliance}. We hence argue that Slang can serve as an interesting proxy for the coverage of language constructs.
We executed a campaign of 100 files generated by each fuzzer on each tool, and repeated each experiment 10 times to ensure statistical significance.
We discuss the methodology for measuring coverage in more detail in Section~\ref{sec:eval:coverage}, especially the exclusion of irrelevant files from the coverage computation.

\para{Results}
Figure~\ref{fig:prev-coverage} shows the results of this coverage campaign.
The coverage achieved by the three state-of-the-art fuzzers is low overall (always under 50\%) and consistent across fuzzers for each target EDA application.
We discuss the coverage results per EDA application.
When targeting Yosys, the three fuzzers also achieve low coverage (between 14\% and 28\%).
A manual analysis reveals that many optimizations and cell types are never touched.
For instance, Listing~\ref{lst:assert} in Appendix~\ref{sec:appendix:snippet-examples} shows code paths for \texttt{assume}, \texttt{asserts} and \texttt{cover} which are never covered by traditional procedural fuzzers.
%
Among all targets, Slang consistently achieves the lowest coverage across fuzzers.
Because Slang is a SystemVerilog parser, this underlines the limited syntactic diversity of the SystemVerilog code generated by the three fuzzers.
In Appendix~\ref{sec:appendix:base-snippet-examples}, Listing \ref{lst:wor} we can see an example of a construct that was uncovered: \texttt{wor} types, with which a bug was later on identified.
%
Verilator is consistently the target for which the fuzzers achieve their best coverage score (between 25\% and 50\%), regardless of which of the three metrics.
Verilator is particularly aggressive in optimizations.
This indicates that the existing fuzzers indeed focus on generating hardware descriptions that are non-trivial to optimize.
Nevertheless, about 50\% of Verilator's code remains uncovered.
Listing~\ref{lst:postdec} in Appendix~\ref{sec:appendix:base-snippet-examples} shows a post-decrement handling construct that was uncovered in Verilator's codebase.
\ourname later identified a translation bug in this construct handler Yosys \#5151, and in Yosys's Slang plugin \#161.

\para{Example}
Verilator is of particular interest when considering fuzzing comprehensiveness because its implementation intertwines language support, optimizations, and simulation logic.
For example, let us consider its implementation for tri-state constructs (\texttt{V3Tristate})~\cite{vanderlinden1994tristate}.
It combines syntax support, optimisation, and simulation functionality.

Regarding syntax support, \texttt{V3Tristate} handles tri-state constructs in the AST.
It identifies where tri-state semantics apply and, when required, restructures ports to represent an \texttt{inout} as an input and dedicated \texttt{\_\_out} and \texttt{\_\_en} signals.

Regarding optimisation, \texttt{V3Tristate} builds a propagation graph to mark signals that participate in tri-state behavior and merges wired nets (wired-OR and wired-AND).
It then performs strength-aware simplification that removes assignments that cannot influence the resolved value and prunes dead logic created by these eliminations.

Regarding simulation, \texttt{V3Tristate} synthesises a two-state implementation that preserves tri-state semantics by materialising driver and enable signals (\texttt{\_\_out} and \texttt{\_\_en}), constructing matching enable/data equations across expressions resolving multiple drivers, and applying pullup/pulldown defaults on undriven bits.
At module boundaries, it rewires ports so the resulting logic is directly executable.

In total, only 30\% of the lines of \texttt{V3Tristate} are covered by the fuzzers, leaving aample space for lurking bugs.
