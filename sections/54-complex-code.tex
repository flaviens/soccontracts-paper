Having generated a pool of base snippets, we now describe how to combine them into complex hardware representations.
We call the resulting fuzzer \ourname.


\para{Motivational example}
Let us consider the base snippet shown in Listing~\ref{lst:multiple-drivers}.
The wire \texttt{conflict\_wire} is subject to a race condition where multiple drivers assign conflicting values.
When packaged as a base snippet, \texttt{conflict\_wire} is not accessed and can be optimised away.
But if code is added into this module to try to access in1 or in2, a known Yosys bug is triggered (Yosys~\#3426, re-discovered by \ourname)
in which \texttt{opt\_clean} can revert the direction of connections.

\begin{lstlisting}[language=verilog,caption={Example of a snippet with multiple drivers to a same variable that is not used.},label={lst:multiple-drivers},breaklines=true]
module multidriven_unhandled (
    input logic [7:0] in1,
    input logic [7:0] in2,
    output logic [7:0] out
);
    wire [7:0] conflict_wire;
    assign conflict_wire = in1;
    assign conflict_wire = in2;
    assign out = in1;
endmodule

\end{lstlisting}

From this motivational example, which follows the main hypothesis formulated in Section~\ref{sec:llms:lessons}, we derive the following design principle.

\begin{newdesignprinciple}
    Combine base snippets to form complex, semantically and syntactically heterogeneous hardware descriptions.
\end{newdesignprinciple}

\subsection{Base snippet combination overview}
\label{sec:complex-code:base-snippet-combination-overview}

\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{figures/diversification_overview/diversification_overview.pdf}
    \caption{Overview of the base snippet combination process.}
    \label{fig:diversification_overview}
\end{figure}


\para{Overview}
\ourname operates by combining the base snippets discussed in Section~\ref{sec:codegen}.
This combination process is driven by three main components as illustrated in Figure~\ref{fig:diversification_overview}.
The parser analyzes the structure of the file and the snippet to identify candidate interfaces for connecting other snippets.
The combinator identifies the best place to inject the snippet into the top module, and injects it in its abstract representation supplied by the parser.
The printer converts the abstract representation back into a SystemVerilog-compliant file, preserving the style and hierarchy identified by the parser and combinator.

\para{Top-level module}
\ourname combines the base snippets and populates them into an LLM-generated top-level module.
The prompt for generating the top-level module is given in Listing~\ref{lst:system-prompt-template} in Appendix~\ref{sec:appendix:snippet-examples}.

\subsection{Parser}
\label{sec:complex-code:parser}

The parser extracts the structural information required to compose base snippets.
Off-the-shelf SystemVerilog parsers, e.g., slang~\cite{popoloski2019slang} or treesitter~\cite{TreeSitter2025}, do not preserve the exact structure of LLM-generated code, which is crucial for exercising uncovered paths in the target EDA software.

\para{Parser operation}
The parser takes both the top module and base snippets.
It produces an AST that represents the structure of the code and focuses on the following objectives.

\para{Dependencies}
First, \ourname's parser must comprehend the dependencies between snippets.
Dependencies include constructs such as functions, modules, types, classes, interfaces, and packages.
This dependency identification is necessary when injecting a snippet as \ourname will have to populate the dependencies adequately in the top module.

\para{Fidelity}
Second, in SystemVerilog, there are many ways of expressing the same construct as we illustrate in Appendix~\ref{sec:appendix:snippet-examples}'s Listing~\ref{lst:ansi-cmp}.
\ournameâ€™s parser must provide sufficient information to reconstruct the parsed snippet in its exact original style as expressed by the LLM.

\para{Variable scope tree creation}
Third, \ourname's parser is responsible for identifying the locations where a base snippet can be injected.
This includes two main parts.
First, determining which variables are available in each scope.
Second, identifying the places in which code injection is not possible.
This includes producing a scope tree that represents the hierarchical structure of the code and the visibility of variables.
The scope tree is also responsible for determining where code cannot be injected, e.g., it detects blocks which are type definitions (\texttt{typedef} in SystemVerilog), in which there cannot be any dynamic code.
Appendix~\ref{sec:appendix:scope-tree} introduces a scope tree example generated by \ourname for a base snippet that covers Slang.

\para{Abstract Representation}
The AST produced by the parser stores the base snippet name, dictionaries for all modules, interfaces, classes, structs, and typedefs, and a dependency map (scope tree) linking them.

\subsection{Combinator}
\label{sec:complex-code:combinator}

\para{Combinator overview}
The combinator assembles the abstract objects produced by the parser.
It starts with the top module and iteratively inserts compatible abstract parsed representations.
It proceeds for a number of iterations that follows a geometric law of parameter $g \in (0,1)$ as detailed in Section~\ref{sec:disparities:analysis}.
The combinator picks snippets randomly with probabilistic distributions that balance diversity and tool support as we will elaborate in Section~\ref{sec:disparities}.

\para{Favoring deep dependencies}
The combinator progressively increases the processing depth between module inputs and outputs.
To do that, the combinator leverages the scope tree prepared by the parser, which lists the variables available in each part of the snippet.
The combinator finds the scopes in which the number of variables that can be used as inputs to the injected modules is maximal.
When a base snippet is injected, if not all the inputs of the modules can be mapped
to preexisting variables in the scope, then it adds new ports to the top module.

\para{Instantiations}
Once an interesting scope is found for a base snippet, the combinator can either use it as a module instance, or inline it.
The latter option typically yields more intricate hardware representations, can then be recombined with another snippet inserted later.
We set inlining probability to 80\% and instantiation to 20\%, fostering optimizations and complex interactions.

\subsection{Printer}
\label{sec:complex-code:printer}

The printer handles the re-generation from the abstract representation produced by the combinator.
Its main objective is to rewrite the code while preserving the style and all the syntactic choices of the original base snippets, thanks to the information transmitted by the parser.
For instance, most objects carry a \texttt{content} attribute storing their original code.
For top-level objects (modules, classes, interfaces), the printer regenerates structure directly from the parser's output.
Lastly, the printer is responsible for generating the new port declarations in the appropriate style, for instance after the combinator mutated the file to inject snippets into other modules.

\subsection{Determinism}
\label{sec:codegen:determinism}

We ensure determinism in two steps: first at the base snippet level, then once they are combined.

\para{Base-snippet level determinism}
We first execute base snippets differentially between the target RTL simulators with 1000 identical stimuli across all target RTL simulators.
If a mismatch between the outputs of a pair of RTL simulators is detected, we manually inspect the test case.
If the discrepancy is due to a bug, we report it.
Otherwise, we discard the non-deterministic snippet.
On average, around 20\% of generated base snippets are non-deterministic.

\para{Combination-level determinism}
Combining deterministic snippets can also lead to non-determinism.
The main sources of non-determinism when combining snippets are variable name clashes, conflicting drivers, representations requiring long stabilization, and assignments to \texttt{X} or \texttt{Z} values.

To mitigate these effects, we first rename all variables when combining modules to prevent name clashes. We create new dedicated variables for each module output, and enforce a 10ns delay between the last clock cycle and any file reads or new cycles.
\texttt{X} and \texttt{Z} are the only non-determinism sources that we occasionally encounter, but are easy to manually identify.
As a result, the files generated by \ourname that combine base snippets for differential fuzzing of EDA software are deterministic.
